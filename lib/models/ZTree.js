// Generated by CoffeeScript 1.6.3
var Extent, RBTree, ZTree;

Extent = require("./Extent.js");

RBTree = require('bintrees').RBTree;

ZTree = (function() {
  var B, BITMAX, FULL, MASK, S, expandExtent, _000_, _001_, _010_, _011_, _100_, _101_;

  B = [0x55555555, 0x33333333, 0x0F0F0F0F, 0x00FF00FF];

  S = [1, 2, 4, 8];

  function ZTree() {
    this.tree = new RBTree(function(a, b) {
      return a.zcode - b.zcode;
    });
  }

  ZTree.prototype.insert = function(entity) {
    entity.zcode = this.zEncode(entity.pos.x | 0, entity.pos.y | 0);
    return this.tree.insert(entity);
  };

  ZTree.prototype.remove = function(entity) {
    return this.tree.remove(entity);
  };

  ZTree.prototype.each = function(callback) {
    return this.tree.each(callback);
  };

  ZTree.prototype.all = function() {
    var all;
    all = [];
    this.tree.each(function(entity) {
      return all.push(entity);
    });
    return all;
  };

  ZTree.prototype.zEncode = function(y, x) {
    x = (x | (x << S[3])) & B[3];
    x = (x | (x << S[2])) & B[2];
    x = (x | (x << S[1])) & B[1];
    x = (x | (x << S[0])) & B[0];
    y = (y | (y << S[3])) & B[3];
    y = (y | (y << S[2])) & B[2];
    y = (y | (y << S[1])) & B[1];
    y = (y | (y << S[0])) & B[0];
    return x | (y << 1);
  };

  expandExtent = new Extent;

  ZTree.prototype.searchExpand = function(extent, x, y, callback, scope) {
    expandExtent.clear().add(extent).expand(x, y);
    return this.searchExtent(expandExtent, callback, scope);
  };

  ZTree.prototype.searchExtent = function(extent, callback, scope) {
    return this.search(extent.ul.x, extent.ul.y, extent.lr.x, extent.lr.y, callback, scope);
  };

  ZTree.prototype.searchR = function(node, minz, maxz, x1, y1, x2, y2, z1, z2, callback, scope) {
    var z, _ref, _ref1;
    if (!node) {
      return;
    }
    z = node.data.zcode;
    if (z < minz) {
      return this.searchR(node.right, minz, maxz, x1, y1, x2, y2, z1, z2, callback, scope);
    }
    if (z > maxz) {
      return this.searchR(node.left, minz, maxz, x1, y1, x2, y2, z1, z2, callback, scope);
    }
    if ((x1 <= (_ref = node.data.pos.x) && _ref <= x2) && (y1 <= (_ref1 = node.data.pos.y) && _ref1 <= y2)) {
      this.searchR(node.left, minz, z, x1, y1, x2, y2, z1, z2, callback, scope);
      callback.call(scope, node.data);
      return this.searchR(node.right, z, maxz, x1, y1, x2, y2, z1, z2, callback, scope);
    } else {
      this.searchR(node.left, minz, this.cleverLitmax(z1, z2, z), x1, y1, x2, y2, z1, z2, callback, scope);
      return this.searchR(node.right, this.cleverBigmin(z1, z2, z), maxz, x1, y1, x2, y2, z1, z2, callback, scope);
    }
  };

  ZTree.prototype.search = function(x1, y1, x2, y2, callback, scope) {
    var z1, z2;
    x1 |= 0;
    y1 |= 0;
    x2 |= 0;
    y2 |= 0;
    z1 = this.zEncode(x1, y1);
    z2 = this.zEncode(x2, y2);
    return this.searchR(this.tree._root, z1, z2, x1, y1, x2, y2, z1, z2, callback, scope);
  };

  ZTree.prototype.stupidLitmax = function(x1, y1, x2, y2, minz, maxz, z) {
    var candidate, x, y, zc, _i, _j;
    candidate = minz;
    for (x = _i = x1; x1 <= x2 ? _i <= x2 : _i >= x2; x = x1 <= x2 ? ++_i : --_i) {
      for (y = _j = y1; y1 <= y2 ? _j <= y2 : _j >= y2; y = y1 <= y2 ? ++_j : --_j) {
        zc = this.zEncode(x, y);
        if (zc > z && zc < candidate) {
          candidate = z;
        }
      }
    }
    return candidate;
  };

  ZTree.prototype.stupidBigmin = function(x1, y1, x2, y2, minz, maxz, z) {
    var candidate, x, y, zc, _i, _j;
    candidate = maxz;
    for (x = _i = x1; x1 <= x2 ? _i <= x2 : _i >= x2; x = x1 <= x2 ? ++_i : --_i) {
      for (y = _j = y1; y1 <= y2 ? _j <= y2 : _j >= y2; y = y1 <= y2 ? ++_j : --_j) {
        zc = this.zEncode(x, y);
        if (zc > z && zc < candidate) {
          candidate = z;
        }
      }
    }
    return candidate;
  };

  _000_ = 0;

  _001_ = 1;

  _010_ = 2;

  _011_ = 3;

  _100_ = 4;

  _101_ = 5;

  MASK = 0xaaaaaaaa;

  FULL = 0xffffffff;

  BITMAX = 31;

  ZTree.prototype.setbits = function(p, v) {
    var mask;
    mask = (MASK >>> (BITMAX - p)) & (~(FULL << p) & FULL);
    return (v | mask) & ~(1 << p) & FULL;
  };

  ZTree.prototype.unsetbits = function(p, v) {
    var mask;
    mask = ~(MASK >>> (BITMAX - p)) & FULL;
    return (v & mask) | (1 << p);
  };

  ZTree.prototype.cleverLitmax = function(minz, maxz, zcode) {
    var litmax, mask, p, v, _i;
    litmax = minz;
    for (p = _i = BITMAX; BITMAX <= 0 ? _i <= 0 : _i >= 0; p = BITMAX <= 0 ? ++_i : --_i) {
      mask = 1 << p;
      v = (zcode & mask) && _100_ || _000_;
      if (minz & mask) {
        v |= _010_;
      }
      if (maxz & mask) {
        v |= _001_;
      }
      if (v === _001_) {
        maxz = this.setbits(p, maxz);
      } else if (v === _011_) {
        return litmax;
      } else if (v === _100_) {
        return maxz;
      } else if (v === _101_) {
        litmax = this.setbits(p, maxz);
        minz = this.unsetbits(p, minz);
      }
    }
    return litmax;
  };

  ZTree.prototype.cleverBigmin = function(minz, maxz, zcode) {
    var bigmin, mask, p, v, _i;
    bigmin = maxz;
    for (p = _i = BITMAX; BITMAX <= 0 ? _i <= 0 : _i >= 0; p = BITMAX <= 0 ? ++_i : --_i) {
      mask = 1 << p;
      v = (zcode & mask) && _100_ || _000_;
      if (minz & mask) {
        v |= _010_;
      }
      if (maxz & mask) {
        v |= _001_;
      }
      if (v === _001_) {
        bigmin = this.unsetbits(p, minz);
        maxz = this.setbits(p, maxz);
      } else if (v === _011_) {
        return minz;
      } else if (v === _100_) {
        return bigmin;
      } else if (v === _101_) {
        minz = this.unsetbits(p, minz);
      }
    }
    return bigmin;
  };

  ZTree.test = function() {
    var tree, x, y, z, zmax, zmin, _i, _j, _ref;
    tree = new ZTree;
    for (x = _i = 0; _i <= 9; x = ++_i) {
      for (y = _j = 0; _j <= 17; y = ++_j) {
        tree.insert({
          x: x,
          y: y
        });
      }
    }
    tree.tree.each(function(d) {
      return console.log(d);
    });
    _ref = [tree.zEncode(3, 5), tree.zEncode(5, 10)], zmin = _ref[0], zmax = _ref[1];
    z = 58;
    console.log('search', tree.search(3, 5, 5, 10));
    console.log('slitmax', tree.stupidLitmax(3, 5, 5, 10, zmin, zmax, z));
    console.log('sbigmin', tree.stupidBigmin(3, 5, 5, 10, zmin, zmax, z));
    console.log('clitmax', tree.cleverLitmax(zmin, zmax, z));
    return console.log('cbigmin', tree.cleverBigmin(zmin, zmax, z));
  };

  return ZTree;

})();

module.exports = ZTree;
